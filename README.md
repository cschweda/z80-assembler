# TRS-80 Model III Z80 Assembler

A complete, browser-based Z80 assembler implementation specifically targeting the **TRS-80 Model III** computer. Built with vanilla JavaScript and ES6 modules, this assembler converts Z80 assembly source code into executable bytecode that can be loaded into a TRS-80 Model III emulator.

## ‚ö†Ô∏è Important: This is an Assembler, Not an Emulator

**What This Project Does:**
- ‚úÖ **Assembles** TRS-80 Model III Z80 assembly source code
- ‚úÖ **Compiles** assembly instructions into Z80 machine code bytecode
- ‚úÖ **Validates** syntax and generates symbol tables
- ‚úÖ **Outputs** hex dumps and memory layouts

**What This Project Does NOT Do:**
- ‚ùå **Does NOT execute** or run the generated bytecode
- ‚ùå **Does NOT emulate** the TRS-80 hardware
- ‚ùå **Does NOT provide** a virtual CPU or runtime environment

**The Distinction:**
- **Assembler** (this project): Translates human-readable assembly code ‚Üí machine code bytecode
- **Emulator** (planned future project): Executes machine code bytecode ‚Üí runs programs

Think of this as a **compiler** for Z80 assembly language. The generated bytecode is ready to be executed by a TRS-80 Model III emulator or loaded onto real hardware, but this tool itself only performs the translation/compilation step.

## Overview

This project provides a full-featured **assembler** (source code compiler) for the Zilog Z80 microprocessor, with specific support for the TRS-80 Model III's memory map, I/O ports, and video display characteristics. The assembler runs entirely in the browser with no external dependencies, making it ideal for educational purposes, retro computing enthusiasts, and developers working with Z80-based systems.

**Input:** Z80 assembly source code (text)  
**Output:** Z80 machine code bytecode (binary) + symbol table + memory dump

The generated bytecode is ready to be executed by a TRS-80 Model III emulator (planned future project) or loaded onto real TRS-80 hardware.

### Key Highlights

- üî® **Assembler/Compiler**: Converts Z80 assembly source ‚Üí machine code bytecode (does NOT execute code)
- ‚úÖ **100% Test Coverage**: All 15 example programs pass comprehensive validation
- üöÄ **Fast Assembly**: Average 0.49ms per program compilation
- üì¶ **Zero Dependencies**: Pure JavaScript implementation
- üé® **Authentic UI**: TRS-80 Model III green-on-black terminal aesthetic
- üîß **Production Ready**: Configured for Netlify deployment with Vite build system
- üìö **Well Documented**: 50% JSDoc coverage with ~1,200 lines of comprehensive documentation

## Features

### Complete Z80 Instruction Set

Supports **all major Z80 instructions** including:

- **8-bit Load Operations**: `LD r,r'`, `LD r,n`, `LD r,(HL)`, `LD (HL),r`, `LD (HL),n`, `LD A,(BC)`, `LD A,(DE)`, `LD (BC),A`, `LD (DE),A`, `LD A,(nn)`, `LD (nn),A`
- **16-bit Load Operations**: `LD dd,nn`, `LD HL,(nn)`, `LD (nn),HL`, `LD SP,HL`, `PUSH qq`, `POP qq`
- **Arithmetic**: `ADD`, `ADC`, `SUB`, `SBC`, `INC`, `DEC`, `NEG`, `DAA`, `CPL`
- **Logic Operations**: `AND`, `OR`, `XOR`, `CP`
- **Rotate & Shift**: `RLCA`, `RLA`, `RRCA`, `RRA`, `RLC`, `RL`, `RRC`, `RR`, `SLA`, `SRA`, `SRL`
- **Bit Manipulation**: `BIT`, `SET`, `RES` (CB-prefixed)
- **Jump & Call**: `JP`, `JR`, `CALL`, `RET`, `DJNZ`, `RST` (with condition codes)
- **Block Transfer**: `LDI`, `LDIR`, `LDD`, `LDDR`, `CPI`, `CPIR`, `CPD`, `CPDR`
- **I/O Operations**: `IN`, `OUT`
- **Exchange**: `EX`, `EXX`
- **Special**: `NOP`, `HALT`, `DI`, `EI`, `SCF`, `CCF`

### Advanced Assembly Features

- **Two-Pass Assembly**: Automatically resolves forward label references
- **Expression Evaluator**: Full arithmetic expression support with operators `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`
- **Symbol Table Management**: Tracks labels, constants (`.EQU`), and relocatable symbols (`.DEFL`)
- **Current Address Reference**: Use `$` to reference the current program counter
- **Deferred Label Resolution**: Correctly handles labels in indirect addressing modes like `LD (LABEL),A`
- **Relative Jump Calculation**: Automatic offset calculation for `JR` and `DJNZ` instructions
- **Comprehensive Error Reporting**: Clear error messages with line and column information

## Getting Started

### Prerequisites

- **Node.js**: v22.21.1 or higher (see `.nvmrc`)
- **Yarn**: 1.22.22 (classic)
- **Modern Browser**: Chrome, Firefox, Safari, or Edge

### Installation

```bash
# Clone the repository
git clone <repository-url>
cd z80-assembler

# Install dependencies
yarn install
```

### Development

```bash
# Start development server with hot reload
yarn dev
```

The application will open automatically in your browser at `http://localhost:5173` (Vite default port).

### Build

```bash
# Build for production
yarn build

# Preview production build locally
yarn preview
```

The built files will be in the `dist/` directory, optimized and ready for deployment.

### Testing

```bash
# Run comprehensive test suite
yarn test
```

#### Test Suite Details

The test suite validates all 15 example programs with detailed output including:

- ‚úì **Bytecode Validation**: Compares generated machine code byte-by-byte against expected values
- ‚úì **Symbol Table Verification**: Validates all label addresses and constants
- ‚úì **Performance Metrics**: Reports assembly time for each test
- ‚úì **Code Preview**: Shows first 16 bytes of generated bytecode
- ‚úì **Symbol Preview**: Displays key symbols and their addresses

**Current Test Results:**
- **15/15 tests passing** ‚úÖ
- **100% success rate**
- **Average assembly time: 0.49ms per test**
- **Total bytecode generated: 367 bytes (0.36KB)**

#### Example Test Output

```
[‚úì PASS] Fill Screen with Solid Blocks
  ID: fillscreen
  Description: Fills the entire TRS-80 Model III screen with the solid block character ($BF)
  Duration: 0.51ms
  Bytes: 15 (expected 15)
  Symbols: 4 (expected 4)
  Bytecode: 21 00 3C 01 00 04 36 BF 23 0B 78 B1 20 F8 76
  Symbols: VRAM:0x3C00, VSIZE:0x400, START:0x4200, FILL:0x4206
```

## Usage

1. **Select an Example**: Use the dropdown to load one of 15 example programs
2. **Edit Source**: Modify the assembly source code in the editor
3. **Assemble**: Click "Assemble" or press Ctrl+Enter
4. **View Results**: 
   - Memory dump shows the generated bytecode
   - Symbol table lists all labels and their addresses
   - Errors and warnings are displayed if any

## Example Programs

The assembler includes **15 comprehensive example programs** that demonstrate various Z80 features and TRS-80 Model III capabilities:

| # | Name | Size | Description | Tests |
|---|------|------|-------------|-------|
| 1 | **Minimal Program** | 2 bytes | Simplest valid program (NOP + HALT) | Basic instruction encoding |
| 2 | **Add 2+2** | 10 bytes | Calculate 2 + 2 = 4 and store result | 8-bit arithmetic, memory store |
| 3 | **Fill Screen** | 15 bytes | Fill video RAM with solid blocks ($BF) | 16-bit loops, counter, indirect addressing |
| 4 | **Clear Screen** | 14 bytes | Clear screen to spaces using LDIR | Block transfer operations |
| 5 | **Sierpinski Triangle** | 33 bytes | Generate fractal pattern with bitwise AND | Nested loops, coordinates, video output |
| 6 | **Checkerboard** | 39 bytes | Animated scrolling checkerboard | Complex patterns, frame animation |
| 7 | **Data Definition** | 30 bytes | Test `.DB`, `.DW`, strings, tables | Data directives, pointers |
| 8 | **Conditional Jumps** | 47 bytes | Exercise all condition codes | Z, NZ, C, NC, P, M flags |
| 9 | **Subroutine Test** | 18 bytes | Test CALL/RET with stack | Subroutine calls, stack operations |
| 10 | **Keyboard Scan** | 20 bytes | Scan TRS-80 keyboard matrix | IN/OUT, I/O ports, keyboard base $3800 |
| 11 | **Bit Manipulation** | 35 bytes | Test BIT, SET, RES instructions | CB-prefixed operations |
| 12 | **Rotate & Shift** | 25 bytes | Test all rotate/shift variants | RLCA, RLA, CB rotates |
| 13 | **16-bit Arithmetic** | 20 bytes | 16-bit ADD, INC, DEC operations | Register pairs, HL arithmetic |
| 14 | **Block Copy** | 41 bytes | Copy "HELLO WORLD!" with LDIR | Block transfer, string operations |
| 15 | **Expression Eval** | 18 bytes | Complex arithmetic expressions | Expression parser, operator precedence |

Each example includes:
- Fully commented source code
- Expected bytecode output
- Expected symbol table
- Test validation

### TRS-80 Model III Specific Examples

Several examples leverage TRS-80 Model III hardware features:

- **Video RAM**: Direct manipulation of the character-mapped display at $3C00
- **Keyboard Matrix**: Memory-mapped keyboard scanning at $3800  
- **Display Characteristics**: 64 columns √ó 16 rows (1024 bytes)
- **Block Graphics**: Use of character $BF (solid block) and $20 (space)

## Assembly Language Syntax

### Supported Directives

| Directive | Syntax | Description | Example |
|-----------|--------|-------------|---------|
| `.ORG` | `.ORG address` | Set origin/start address | `.ORG $4200` |
| `.DB` | `[LABEL:] .DB value[,value...]` | Define byte(s) | `DATA: .DB $FF, 42, "Hello"` |
| `.DW` | `[LABEL:] .DW value[,value...]` | Define word(s) (16-bit, little-endian) | `PTR: .DW $1234` |
| `.DS` | `[LABEL:] .DS count` | Define space (reserve bytes) | `BUFFER: .DS 100` |
| `.EQU` | `LABEL .EQU value` | Define constant (immutable) | `VRAM .EQU $3C00` |
| `.DEFL` | `LABEL .DEFL value` | Define label (mutable) | `TEMP .DEFL 0` |
| `.END` | `.END` | End of source (optional) | `.END` |

**Notes:**
- Labels can be on the same line or separate line before directives
- String literals in `.DB` are converted to ASCII bytes
- `.DW` stores values in little-endian format (LSB first)
- Default origin is `$4200` (TRS-80 Model III user RAM)

### Number Formats

The assembler supports multiple number formats:

| Format | Syntax | Example | Decimal Value |
|--------|--------|---------|---------------|
| Hexadecimal | `$nn` or `0xnn` or `nnH` | `$FF`, `0xFF`, `FFH` | 255 |
| Binary | `%nnnnnnnn` | `%10101010` | 170 |
| Decimal | `nnn` | `255` | 255 |

### Expression Syntax

Expressions can use:
- **Arithmetic**: `+`, `-`, `*`, `/`, `%` (modulo)
- **Bitwise**: `&` (AND), `|` (OR), `^` (XOR)
- **Shift**: `<<` (left), `>>` (right)
- **Parentheses**: For grouping
- **Labels**: Reference symbol addresses
- **Current Address**: `$` refers to current program counter

**Examples:**
```asm
OFFSET  .EQU  16
COMBO   .EQU  $1000 + OFFSET      ; = $1010
MASK    .EQU  %11110000 & $FF     ; = $F0
HERE    .EQU  $ + 10               ; Current address + 10
```

## TRS-80 Model III Hardware Specifications

### Memory Map

This assembler is specifically configured for the **TRS-80 Model III** memory layout:

| Address Range | Size | Description | Access |
|---------------|------|-------------|--------|
| `$0000‚Äì$37FF` | 14 KB | ROM (Level II BASIC) | Read-only |
| `$3800‚Äì$3BFF` | 1 KB | Keyboard matrix (memory-mapped) | Read |
| `$3C00‚Äì$3FFF` | 1 KB | Video RAM (64√ó16 character cells) | Read/Write |
| `$4000‚Äì$7FFF` | 16 KB | User RAM (base configuration) | Read/Write |
| `$8000‚Äì$FFFF` | 32 KB | Expansion RAM (optional) | Read/Write |

**Default Origin**: `$4200` (recommended start for user programs)

### Video Display

- **Resolution**: 64 columns √ó 16 rows = 1,024 character cells
- **Character Set**: 2√ó3 pixel block graphics (128 characters)
- **Colors**: Green phosphor on black (hardware), simulated in UI
- **Video RAM**: Linear mapping at `$3C00`
  - Offset 0 = top-left
  - Offset 63 = top-right
  - Offset 1023 = bottom-right

**Common Characters:**
- `$20` = Space (blank)
- `$BF` = Solid block (all pixels lit)
- `$41‚Äì$5A` = Uppercase letters A-Z

### Keyboard

- **Base Address**: `$3800`
- **Matrix**: 8√ó8 memory-mapped matrix
- **Scanning**: Read bytes to detect key presses
- **Inverted Logic**: Clear bit = key pressed

## Architecture

The assembler uses a modular, pipeline-based architecture:

```
Source Code ‚Üí Lexer ‚Üí Parser (Pass 1) ‚Üí Parser (Pass 2) ‚Üí Code Generator ‚Üí Bytecode
                         ‚Üì                    ‚Üì                  ‚Üì
                   Symbol Table          Instructions      Final Addresses
```

### Core Modules

#### 1. **Lexer** (`src/lexer.js`)
- **Purpose**: Tokenizes assembly source code into discrete tokens
- **Tokens**: Keywords, mnemonics, registers, numbers, operators, labels, strings
- **Number Parsing**: Handles hex ($FF, 0xFF, FFH), binary (%10101010), decimal
- **Line Tracking**: Maintains line and column information for error reporting

#### 2. **Parser** (`src/parser.js`)
- **Two-Pass Design**:
  - **Pass 1**: Builds symbol table, calculates instruction sizes, tracks addresses
  - **Pass 2**: Generates instruction objects with operands, handles forward references
- **Features**:
  - Forward reference resolution
  - Label-before-directive syntax support (e.g., `LABEL .EQU value`)
  - Deferred operand resolution for indirect addressing
  - Current address (`$`) tracking
- **Output**: Array of instruction objects with operands and metadata

#### 3. **Code Generator** (`src/codegen.js`)
- **Purpose**: Converts parsed instructions into machine code bytes
- **Features**:
  - Two-pass generation for final address resolution
  - Relative jump offset calculation
  - Label reference resolution in operands
  - Instruction-specific encoding logic
- **Output**: Array of bytes ready for execution

#### 4. **Expression Evaluator** (`src/evaluator.js`)
- **Purpose**: Evaluates arithmetic expressions with labels and symbols
- **Algorithm**: Shunting-yard algorithm for operator precedence
- **Operators**: `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`
- **Features**: Label lookup, current address (`$`) substitution, parentheses

#### 5. **Opcodes** (`src/opcodes.js`)
- **Purpose**: Instruction encoding tables and encoding functions
- **Coverage**: All Z80 instructions including prefixed (CB, DD, ED, FD)
- **Format**: Maps instruction patterns to opcode bytes and sizes

#### 6. **Assembler** (`src/assembler.js`)
- **Purpose**: Main orchestrator that coordinates all modules
- **Interface**: Simple `assemble(source)` method
- **Output**: Object containing bytecode, symbol table, errors, warnings

### UI Components

- **Main UI** (`src/main.js`) - Application initialization and event handling
- **Examples** (`src/ui/examples.js`) - Dropdown population and example loading
- **Formatter** (`src/utils/formatter.js`) - Memory dump and symbol table formatting

### Data Flow

1. **User Input** ‚Üí Source code entered or example selected
2. **Lexer** ‚Üí Tokenizes source into structured tokens
3. **Parser Pass 1** ‚Üí Builds symbol table, calculates sizes
4. **Parser Pass 2** ‚Üí Creates instruction objects with operands
5. **Code Generator** ‚Üí Produces final bytecode with resolved addresses
6. **UI Display** ‚Üí Shows memory dump, symbols, errors/warnings

## Deployment

### Netlify (Recommended)

The project is pre-configured for Netlify deployment:

1. **Connect Repository**: Link your Git repository to Netlify
2. **Build Settings** (automatic from `netlify.toml`):
   - Build command: `yarn build`
   - Publish directory: `dist`
3. **Deploy**: Netlify will automatically build and deploy

The `netlify.toml` file includes SPA routing configuration for client-side navigation.

### Manual Deployment

```bash
# Build the project
yarn build

# Deploy the dist/ folder to any static hosting:
# - GitHub Pages
# - Vercel
# - AWS S3 + CloudFront
# - Azure Static Web Apps
# - Any web server
```

## Development Guide

### Project Structure

```
z80-assembler/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ assembler.js          # Main assembler orchestrator
‚îÇ   ‚îú‚îÄ‚îÄ lexer.js              # Tokenizer
‚îÇ   ‚îú‚îÄ‚îÄ parser.js             # Two-pass parser
‚îÇ   ‚îú‚îÄ‚îÄ codegen.js            # Code generator
‚îÇ   ‚îú‚îÄ‚îÄ evaluator.js          # Expression evaluator
‚îÇ   ‚îú‚îÄ‚îÄ opcodes.js            # Z80 instruction encodings
‚îÇ   ‚îú‚îÄ‚îÄ constants.js          # Token types, registers, memory map
‚îÇ   ‚îú‚îÄ‚îÄ main.js               # UI initialization
‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples.js       # Example program loader
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ formatter.js      # Output formatting
‚îÇ   ‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ programs.js       # 15 example programs
‚îÇ   ‚îî‚îÄ‚îÄ tests/
‚îÇ       ‚îî‚îÄ‚îÄ test-suite.js     # Comprehensive test suite
‚îú‚îÄ‚îÄ styles/
‚îÇ   ‚îî‚îÄ‚îÄ main.css              # TRS-80 themed styling
‚îú‚îÄ‚îÄ index.html                # Main HTML page
‚îú‚îÄ‚îÄ vite.config.js            # Vite configuration
‚îú‚îÄ‚îÄ netlify.toml              # Netlify deployment config
‚îú‚îÄ‚îÄ package.json              # Project dependencies
‚îú‚îÄ‚îÄ .nvmrc                    # Node version specification
‚îî‚îÄ‚îÄ .gitignore                # Git ignore rules
```

### Adding New Instructions

1. Add opcode pattern to `src/opcodes.js`
2. Add encoding function if needed
3. Add test case to `src/examples/programs.js`
4. Run `yarn test` to validate

### Code Style

- ES6 modules with `import`/`export`
- No external runtime dependencies
- Comprehensive inline comments
- Consistent naming: camelCase for functions, UPPER_CASE for constants

## Technical Implementation Notes

### Two-Pass Assembly Explained

**Pass 1**: Symbol Table Construction
- Iterates through all source lines
- Tracks `currentAddress` as instructions/data are encountered
- Records label addresses in symbol table
- Handles `.EQU` constants immediately
- Calculates instruction sizes (some may be estimates for forward refs)

**Pass 2**: Instruction Generation
- Uses completed symbol table from Pass 1
- Creates instruction objects with operands
- Stores label references as `LABEL_REF` objects for deferred resolution
- Handles forward references correctly

**Code Generation**: Final Resolution
- First pass: Generates bytecode, updates symbol table with final addresses
- Second pass: Re-encodes instructions containing `LABEL_REF` objects
- Ensures all addresses are correct, including labels on directives

### Relative Jump Calculation

For `JR` and `DJNZ`:
```
offset = target_address - (instruction_address + 2)
```
The offset is relative to the address **after** the instruction (PC + 2).

### Label Resolution in Indirect Addressing

For instructions like `LD (LABEL),A`:
- Parser creates `{ type: 'LABEL_REF', name: 'LABEL' }`
- Code generator resolves to actual address from symbol table
- Ensures correct address even if label is defined later

## JSDoc Documentation

### Comprehensive Code Documentation

The codebase includes **extensive JSDoc documentation** for improved maintainability and developer experience:

**Current Status**: **6 out of 12 files (50%)** fully documented with ~1,200 lines of JSDoc

**Completed Files:**
- ‚úÖ Core assembler (`assembler.js`)
- ‚úÖ Constants and enumerations (`constants.js`)
- ‚úÖ Expression evaluator (`evaluator.js`)
- ‚úÖ Output formatters (`utils/formatter.js`)
- ‚úÖ UI components (`ui/examples.js`, `main.js`)

**Benefits:**
- üéØ **IDE Support**: Full IntelliSense autocomplete in VSCode, WebStorm, etc.
- üìö **Type Safety**: TypeScript-like type checking in JavaScript
- üîç **API Documentation**: Clear parameter and return type information
- üí° **Usage Examples**: Real-world code examples for each function
- üèóÔ∏è **Architecture Clarity**: Module purposes and relationships documented

**Generate HTML Documentation:**
```bash
npm install -g jsdoc
jsdoc src -r -d docs
```

See `JSDOC_GUIDE.md` for complete documentation patterns and `JSDOC_STATUS.md` for progress tracking.

## Browser Compatibility

- **Chrome**: ‚úÖ Fully supported
- **Firefox**: ‚úÖ Fully supported
- **Safari**: ‚úÖ Fully supported (14+)
- **Edge**: ‚úÖ Fully supported

Requires ES6 module support (all modern browsers).

## License

MIT

---

**Built with ‚ù§Ô∏è for retro computing enthusiasts and Z80 developers**

